import { IconProperties } from '@lordicon/web';
import { LegacyIconProperties } from '@lordicon/web';
import { Player } from '@lordicon/web';

/**
 * The __Boomerang__ trigger plays the animation forward when you hover over the element,
 * and after reaching the end, it automatically plays in reverse.
 */
export declare class Boomerang implements Trigger {
    protected player: Player;
    protected element: HTMLElement;
    protected targetElement: HTMLElement;
    /**
     * Animation segments for mouse enter and leave actions.
     * segments[0] - segment for mouse enter
     * segments[1] - segment for mouse leave
     */
    protected segments?: [FrameSegment, FrameSegment];
    /**
     * Queue to manage playback requests.
     */
    protected queue: number[];
    protected connected: boolean;
    protected targetState?: string;
    protected delayTimer: any;
    protected intersectionObserver: IntersectionObserver | undefined;
    constructor(player: Player, element: HTMLElement, targetElement: HTMLElement);
    onConnected(): void;
    onDisconnected(): void;
    onMouseEnter(): void;
    onComplete(): void;
    onState(): void;
    onClick(): void;
    play(handleDelay?: boolean): void;
    replay(): void;
    protected scheduleDelayedPlay(): void;
    /**
     * Processes the segment queue and plays the next segment if the player is not currently playing.
     */
    protected handleQueue(): void;
    /**
     * Updates the animation segments based on the current player state and parameters.
     */
    protected handleState(): void;
    protected initIntersectionObserver(): void;
    protected resetIntersectionObserver(): void;
    protected resetDelayTimer(): void;
    protected resetState(): boolean;
    protected resetPlayer(): void;
    protected cleanup(): void;
    get intro(): string | null;
    get delay(): number;
    get loading(): boolean;
    get clickToReplay(): boolean;
}

/**
 * The __Click__ trigger plays the animation when the icon (its target) is clicked or tapped.
 */
export declare class Click implements Trigger {
    protected player: Player;
    protected element: HTMLElement;
    protected targetElement: HTMLElement;
    protected connected: boolean;
    protected targetState?: string;
    protected delayTimer: any;
    protected intersectionObserver: IntersectionObserver | undefined;
    constructor(player: Player, element: HTMLElement, targetElement: HTMLElement);
    onConnected(): void;
    onDisconnected(): void;
    onComplete(): void;
    onClick(): void;
    play(handleDelay?: boolean): void;
    replay(): void;
    protected scheduleDelayedPlay(): void;
    protected initIntersectionObserver(): void;
    protected resetIntersectionObserver(): void;
    protected resetDelayTimer(): void;
    protected resetState(): void;
    protected cleanup(): void;
    get intro(): string | null;
    get delay(): number;
    get loading(): boolean;
}

/**
 * Registers the `lord-icon` custom element and attaches all built-in animation triggers.
 *
 * This function should be called once in your application before using the `<lord-icon>` element in your markup.
 * It registers the following triggers:
 * - `in`
 * - `click`
 * - `hover`
 * - `loop`
 * - `loop-on-hover`
 * - `morph`
 * - `boomerang`
 * - `sequence`
 *
 * ## Example usage in JavaScript:
 * ```js
 * import { defineElement } from '@lordicon/element';
 * defineElement();
 * ```
 *
 * ## Example usage in HTML (after calling `defineElement`):
 * ```html
 * <lord-icon trigger="hover" src="/icons/confetti.json"></lord-icon>
 * ```
 */
export declare function defineElement(): void;

/**
 * The Lordicon custom element class.
 * Handles icon loading, rendering, customization, and interaction logic.
 */
declare class Element_2 extends HTMLElement {
    protected static _definedTriggers: Map<string, TriggerConstructor>;
    /**
     * Returns the current version of the element.
     */
    static get version(): string;
    /**
     * Returns the list of attributes to observe for changes.
     */
    static get observedAttributes(): SUPPORTED_ATTRIBUTES[];
    /**
     * Registers a custom trigger for icon interaction.
     * Triggers define how the icon responds to user actions.
     * @param name The name of the trigger.
     * @param triggerClass The trigger class constructor.
     */
    static defineTrigger(name: string, triggerClass: TriggerConstructor): void;
    protected _root?: ShadowRoot;
    protected _isConnected: boolean;
    protected _ready: boolean;
    protected _assignedIconData?: IconData;
    protected _loadedIconData?: IconData;
    protected _triggerInstance?: Trigger;
    protected _playerInstance?: Player;
    /**
     * Stores a callback for deferred icon loading, used by lazy/interation/delay strategies.
     */
    delayedLoading: ((cancel?: boolean) => void) | null;
    /**
     * Handles changes to observed attributes and delegates to the appropriate handler.
     * @param name The attribute name.
     * @param oldValue The previous value.
     * @param newValue The new value.
     */
    protected attributeChangedCallback(name: SUPPORTED_ATTRIBUTES, _oldValue: any, _newValue: any): void;
    /**
     * Called when the element is added to the DOM.
     * Sets up shadow DOM, styles, and loading strategy.
     */
    protected connectedCallback(): void;
    /**
     * Called when the element is removed from the DOM.
     * Cleans up any resources and event listeners.
     */
    protected disconnectedCallback(): void;
    /**
     * Creates the shadow DOM structure and attaches styles and slots.
     */
    protected createElements(): void;
    /**
     * Factory method for creating a Player instance.
     * Can be overridden for custom player instantiation.
     */
    protected playerFactory(container: HTMLElement, iconData: IconData, properties: IconProperties & LegacyIconProperties): Player;
    /**
     * Instantiates the Player and sets up dynamic styles, triggers, and event listeners.
     * Handles asynchronous icon data loading.
     */
    protected createPlayer(): Promise<void>;
    /**
     * Destroys the Player and Trigger instances, cleaning up all resources.
     * Called when the icon data changes or the element is disconnected.
     */
    protected destroyPlayer(): void;
    /**
     * Loads icon data from the 'src' attribute or uses the assigned icon data.
     * Returns the icon data object or undefined if loading fails.
     */
    protected loadIconData(): Promise<IconData>;
    /**
     * Synchronizes the element's state with the Player instance.
     * Updates CSS variables and other dynamic properties.
     */
    protected refresh(): void;
    /**
     * Updates CSS variables for icon colors based on the Player's palette.
     * CSS variables take precedence over other color assignments.
     */
    protected movePaletteToCssVariables(): void;
    /**
     * Called when the 'target' attribute changes.
     * Reloads the trigger to use the new target element.
     */
    protected targetChanged(): void;
    /**
     * Called when the 'loading' attribute changes.
     */
    protected loadingChanged(): void;
    /**
     * Called when the 'trigger' attribute changes.
     * Disconnects the old trigger and instantiates the new one.
     */
    protected triggerChanged(): void;
    /**
     * Called when the 'colors' attribute changes.
     * Updates the Player's color palette.
     */
    protected colorsChanged(): void;
    /**
     * Called when the 'stroke' attribute changes.
     * Updates the Player's stroke width.
     */
    protected strokeChanged(): void;
    /**
     * Called when the 'speed' attribute changes.
     * Updates the Player's animation speed.
     */
    protected speedChanged(): void;
    /**
     * Called when the 'state' attribute changes.
     * Updates the Player's animation state.
     */
    protected stateChanged(): void;
    /**
     * Called when the 'icon' attribute changes.
     * Reloads the Player with the new icon.
     */
    protected iconChanged(): void;
    /**
     * Called when the 'src' attribute changes.
     * Reloads the Player with the new icon source.
     */
    protected srcChanged(): void;
    /**
     * Directly assigns icon data to the element.
     * Triggers a reload if the data changes.
     */
    set icon(value: IconData | undefined);
    /**
     * Gets the currently assigned or loaded icon data.
     */
    get icon(): IconData | undefined;
    /**
     * Sets the 'src' attribute for loading icon data from a URL.
     */
    set src(value: string | null);
    /**
     * Gets the current 'src' attribute value.
     */
    get src(): string | null;
    /**
     * Sets the animation state for the icon.
     * You can check available states from the player instance.
     */
    set state(value: string | null);
    /**
     * Gets the current animation state.
     */
    get state(): string | null;
    /**
     * Sets the color palette for the icon.
     * Accepts a comma-separated string, e.g. 'primary:#fdd394,secondary:#03a9f4'.
     */
    set colors(value: string | null);
    /**
     * Gets the current color palette string.
     */
    get colors(): string | null;
    /**
     * Sets the trigger name for icon interaction.
     * The trigger must be registered beforehand.
     */
    set trigger(value: string | null);
    /**
     * Gets the current trigger name.
     */
    get trigger(): string | null;
    /**
     * Sets the loading strategy for the icon.
     * Options: 'lazy', 'interaction', or 'delay'.
     */
    set loading(value: LoadingType | null);
    /**
     * Gets the current loading strategy.
     */
    get loading(): LoadingType | null;
    /**
     * Sets the CSS selector for the target element used for event listening.
     */
    set target(value: string | null);
    /**
     * Gets the current target selector.
     */
    get target(): string | null;
    /**
     * Sets the stroke style for the icon (e.g., 1, 2, 3, light, regular, bold).
     */
    set stroke(value: string | null);
    /**
     * Gets the current stroke width.
     */
    get stroke(): string | null;
    /**
     * Sets the animation speed for the icon.
     * Accepts a number or a string that can be parsed to a number.
     */
    set speed(value: string | number | null);
    /**
     * Gets the current animation speed.
     * Returns 1 if not set or invalid.
     */
    get speed(): number;
    /**
     * Returns true if the element is fully initialized and ready for interaction.
     * You can listen for the 'ready' event to detect readiness.
     */
    get ready(): boolean;
    /**
     * Returns a promise that resolves when the element is ready.
     * Useful for awaiting initialization in external code.
     */
    get readyPromise(): Promise<void>;
    /**
     * Returns the Player instance associated with this element.
     */
    get playerInstance(): Player | undefined;
    /**
     * Returns the Trigger instance associated with this element.
     */
    get triggerInstance(): Trigger | undefined;
    /**
     * Returns the animation container element inside the shadow DOM.
     */
    get animationContainer(): HTMLElement | undefined;
}
export { Element_2 as Element }

declare type FrameSegment = [number, number];

declare type FrameSegment_2 = [number, number];

/**
 * The __Hover__ trigger plays the animation from the first to the last frame when the cursor hovers over the icon (target).
 */
export declare class Hover implements Trigger {
    protected player: Player;
    protected element: HTMLElement;
    protected targetElement: HTMLElement;
    protected connected: boolean;
    protected targetState?: string;
    protected delayTimer: any;
    protected intersectionObserver: IntersectionObserver | undefined;
    constructor(player: Player, element: HTMLElement, targetElement: HTMLElement);
    onConnected(): void;
    onDisconnected(): void;
    onComplete(): void;
    onHover(): void;
    onClick(): void;
    play(handleDelay?: boolean): void;
    replay(): void;
    protected scheduleDelayedPlay(): void;
    protected initIntersectionObserver(): void;
    protected resetIntersectionObserver(): void;
    protected resetDelayTimer(): void;
    protected resetState(): void;
    protected cleanup(): void;
    get intro(): string | null;
    get delay(): number;
    get loading(): boolean;
    get clickToReplay(): boolean;
}

/**
 * Icon animation data in Lottie JSON format.
 * This player is optimized for icons from [Lordicon](https://lordicon.com/).
 */
export declare type IconData = any;

/**
 * The __In__ trigger plays the animation when the icon (target) enters the user's viewport.
 */
export declare class In implements Trigger {
    protected player: Player;
    protected element: HTMLElement;
    protected targetElement: HTMLElement;
    protected connected: boolean;
    protected delayTimer: any;
    protected intersectionObserver: IntersectionObserver | undefined;
    constructor(player: Player, element: HTMLElement, targetElement: HTMLElement);
    onConnected(): void;
    onDisconnected(): void;
    onClick(): void;
    play(handleDelay?: boolean): void;
    protected scheduleDelayedPlay(): void;
    protected initIntersectionObserver(): void;
    protected resetIntersectionObserver(): void;
    protected resetDelayTimer(): void;
    protected cleanup(): void;
    get delay(): number;
    get loading(): boolean;
    get clickToReplay(): boolean;
}

/**
 * Defines the available strategies for loading icons in the custom element.
 * - 'lazy': Loads the icon when it enters the viewport.
 * - 'interaction': Loads the icon after a user interaction.
 * - 'delay': Loads the icon after a specified delay.
 */
declare type LoadingType = 'lazy' | 'interaction' | 'delay';

/**
 * The __Loop__ trigger plays the animation from the first to the last frame infinitely, with no interaction necessary.
 */
export declare class Loop implements Trigger {
    protected player: Player;
    protected element: HTMLElement;
    protected targetElement: HTMLElement;
    protected delayTimer: any;
    constructor(player: Player, element: HTMLElement, targetElement: HTMLElement);
    onReady(): void;
    onComplete(): void;
    onDisconnected(): void;
    play(): void;
    protected scheduleDelayedPlay(): void;
    protected resetDelayTimer(): void;
    get delay(): number;
}

/**
 * The __LoopOnHover__ trigger plays the animation from the first to the last frame in an infinite loop while the cursor hovers over the icon (target).
 */
export declare class LoopOnHover implements Trigger {
    protected player: Player;
    protected element: HTMLElement;
    protected targetElement: HTMLElement;
    protected delayTimer: any;
    protected mouseIn: boolean;
    constructor(player: Player, element: HTMLElement, targetElement: HTMLElement);
    onConnected(): void;
    onDisconnected(): void;
    onMouseEnter(): void;
    onMouseLeave(): void;
    onComplete(): void;
    play(): void;
    protected scheduleDelayedPlay(): void;
    protected resetDelayTimer(): void;
    get delay(): number;
}

/**
 * The __Morph__ trigger plays the animation forward (from the first to the last frame) when hovering over the icon,
 * and reverses it (from the last to the first frame) when the cursor leaves.
 * For some states, it plays a part of the animation on enter, and plays the remaining part when the cursor leaves.
 */
export declare class Morph implements Trigger {
    protected player: Player;
    protected element: HTMLElement;
    protected targetElement: HTMLElement;
    /**
     * Animation segments for mouse enter and leave actions.
     * segments[0] - segment for mouse enter
     * segments[1] - segment for mouse leave
     */
    protected segments?: [FrameSegment_2, FrameSegment_2];
    /**
     * Queue to manage playback requests.
     */
    protected queue: number[];
    protected mouseIn: boolean;
    protected connected: boolean;
    protected targetState?: string;
    protected delayTimer: any;
    protected mutationTimer: any;
    protected intersectionObserver: IntersectionObserver | undefined;
    protected observer: MutationObserver | undefined;
    constructor(player: Player, element: HTMLElement, targetElement: HTMLElement);
    onConnected(): void;
    onDisconnected(): void;
    onMouseEnter(): void;
    onMouseLeave(): void;
    onComplete(): void;
    onState(): void;
    onClick(): void;
    play(handleDelay?: boolean): void;
    replay(): void;
    triggerEnter(): void;
    triggerLeave(): void;
    protected scheduleDelayedPlay(): void;
    /**
     * Processes the segment queue and plays the next segment if the player is not currently playing.
     */
    protected handleQueue(): void;
    /**
     * Updates the animation segments based on the current player state and parameters.
     */
    protected handleState(): void;
    protected initIntersectionObserver(): void;
    protected resetIntersectionObserver(): void;
    protected initMutationObserver(): void;
    protected resetMutationObserver(): void;
    protected resetDelayTimer(): void;
    protected resetState(): boolean;
    protected resetPlayer(): void;
    protected cleanup(): void;
    get intro(): string | null;
    get delay(): number;
    get loading(): boolean;
    get clickToReplay(): boolean;
    get mode(): [TRIGGER_MODE, string?];
}

export { Player }

/**
 * The __Sequence__ trigger allows you to define complex animation scenarios using a simple sequence definition.
 *
 * Example usage:
 * ```html
 * <lord-icon trigger="sequence" sequence="state:intro-empty,play,state:hover-empty,play,state:morph-fill,play,state:morph-erase,play,state:intro-empty,delay:first:last:500,play:reverse" src="/trash.json"></lord-icon>
 * ```
 */
export declare class Sequence implements Trigger {
    protected player: Player;
    protected element: HTMLElement;
    protected targetElement: HTMLElement;
    protected sequenceIndex: number;
    protected frameState: string | null;
    protected frameDelayFirst: number | null;
    protected frameDelayLast: number | null;
    protected timer: any;
    protected observer: MutationObserver;
    constructor(player: Player, element: HTMLElement, targetElement: HTMLElement);
    onReady(): void;
    onComplete(): void;
    onConnected(): void;
    onDisconnected(): void;
    protected reset(): void;
    protected takeStep(): {
        action: string;
        params: string[];
    };
    protected handleStep(action: string, params: string[]): void;
    protected step(): void;
    get sequence(): string;
    get speed(): number;
}

/**
 * Enumerates all supported attributes for the custom element.
 */
declare type SUPPORTED_ATTRIBUTES = 'colors' | 'src' | 'state' | 'trigger' | 'loading' | 'target' | 'stroke' | 'speed';

/**
 * Interface for creating custom triggers.
 *
 * Triggers allow you to define custom interactions for the icon element.
 * Implement this interface to control how the icon responds to events.
 *
 * You have access to:
 * - `player`: The animation player instance.
 * - `element`: The custom icon element.
 * - `targetElement`: The element that triggers the interaction.
 *
 * Example:
 * ```js
 * class CustomTrigger {
 *   constructor(player, element, targetElement) {
 *     this.player = player;
 *     this.element = element;
 *     this.targetElement = targetElement;
 *   }
 *   onReady() {
 *     this.player.play();
 *   }
 * }
 * Element.defineTrigger('custom', CustomTrigger);
 * ```
 */
export declare interface Trigger {
    /**
     * The trigger has been connected to the element.
     */
    onConnected?: () => void;
    /**
     * The trigger has been disconnected from the element.
     *
     * Note: Remember to remove any potential event listeners you assigned earlier in this trigger.
     */
    onDisconnected?: () => void;
    /**
     * The player is ready. Now you can control the animation and icon properties with it.
     */
    onReady?: () => void;
    /**
     * The player has completed an animation.
     */
    onComplete?: () => void;
    /**
     * The player has rendered a frame.
     */
    onFrame?: () => void;
    /**
     * The player was refreshed, for example, due to icon customization.
     */
    onRefresh?: () => void;
    /**
     * State change event.
     */
    onState?: () => void;
}

declare type TRIGGER_MODE = 'hover' | 'class' | 'manual';

/**
 * Constructor type for custom triggers.
 *
 * Use this to define how your trigger is created.
 *
 * @param player The animation player instance.
 * @param element The custom icon element.
 * @param targetElement The element that triggers the interaction.
 */
export declare interface TriggerConstructor {
    new (player: Player, element: HTMLElement, targetElement: HTMLElement): Trigger;
}

export { }
